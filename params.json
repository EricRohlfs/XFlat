{"tagline":"A simple but powerful embedded XML object DB.","google":"","body":"XFlat\r\n=====\r\n\r\nA lightweight embedded no-sql object DB persisting objects to flat XML files.\r\nXFlat is a completely free alternative to db4o for an embedded object DB.\r\n\r\n----\r\n\r\nSo you've got a Java application, and need to persist some data.  Cool.  Just write it to a file.\r\n\r\n> Well, my data's in a bunch of POJOs.\r\n\r\nOk that's easy, just serialize it to XML and drop it into a DOM, then write it to a file.\r\n\r\n> Alright, that sounds easy enough.  But wait a second, I need random access to my saved POJOs.\r\n\r\nWell thats a bit harder, but you could write a class to inspect the DOM and pull out the data you need.\r\n\r\n> But I also need to query my POJOs by arbitrary criteria.\r\n\r\nLooks like you need a database.  Take a look at db4o or Sql Lite\r\n\r\n> Well I'd prefer not to have to deal with Sql, and I may need to inspect or transform my data as XML.\r\n\r\nOh, well in that case XFlat is for you!\r\n\r\n---\r\n\r\nXFlat is a single lightweight JAR that persists XML DOM Elements to flat files.\r\nIt presents as a CRUD interface to XML Elements that can be queried by ID or arbitrary XPath expressions.\r\nBecause it is stored in flat files, XFlat is not relational and is schemaless.\r\nXFlat is currently effective for table sizes up to the dozens of KB.  Future versions will contain engines that are\r\neffective up to the hundreds of MB, using memory-mapped files.\r\n\r\n\r\n#### Features:\r\n* Pure XML data files\r\n  * XFlat's data files are pure XML.  This means they can be inspected, queried, transformed and manipulated by common\r\nXML tools like XSLT and XQuery.  It is trivial to create a process to export your entire database, or import data\r\nfrom another process into your database by directly manipulating the XML (provided the database is not running during\r\nthe import, which is simple to control).  XFlat will automatically re-index the data files on startup if they have\r\nchanged.\r\n\r\n\r\n* POJO mapping to XML\r\n  * XFlat maps POJOs to JDOM `Element` objects using JAXB.  The underlying implementation can be swapped if necessary.\r\nThe JAXB context is only loaded if it is used, so you can avoid it completely by specifying custom converters,\r\nor using only the JDOM CRUD interface.\r\n\r\n\r\n* Queriable by XPath expressions\r\n  * Tables can be queried by any arbitrary XPath expression using the table row as the context.  The expression\r\nselects a part of the `Element` that is convertible to the value which is being matched, then the matching is performed\r\nusing Hamcrest Matchers.  Breaking the query into XPath expressions and values allows the engine to leverage indexes\r\neffectively, much more easily than if we used XQuery.  Future versions may support XQuery.\r\n\r\n\r\n* Multiple swappable Engines (to be implemented)\r\n  * The management of each table is handled by an Engine.  As a table grows or shrinks, the appropriate Engine for managing\r\nthe data is swapped in behind the scenes.  For example, very small tables can use an engine that loads the whole\r\nXML DOM in-memory, while very large tables can use an engine that manipulates a memory-mapped file.  Only one engine\r\nis implemented for version 1.\r\n\r\n\r\n\r\n* Indexing on XPath expressions (to be implemented)\r\n  * Engines can take advantage of indexes that are based on any arbitrary XPath expression.  The expression selects a\r\npart of the `Element` that is converted to a `Comparable` (such as an Integer), then the engine can map that `Comparable`\r\nto the row and binary search indexes to improve performance.\r\n\r\n\r\n\r\n* Sharding by ID (implemented) or on arbitrary XPath expressions (to be implemented)\r\n  * A table can be sharded across multiple files based on a sharding key selected by an XPath expression.  The expression\r\nselects a part of the `Element` that is converted to a `Comparable`, then a `RangeProvider` determines which file to store\r\nthe Element in.\r\n\r\n\r\n* Transactions\r\n  * XFlat supports Transactions that by default span all tables in the database.  Currently XFlat only implements snapshot-isolation transactions,\r\nserializable transactions are planned for a future version.\r\n\r\n====\r\n\r\nRequired dependencies:\r\n* Java 7\r\n\r\n* JDOM 2\r\n  * jdom-2.0.4.jar\r\n  \r\n* Hamcrest matchers 1.3\r\n  * hamcrest-core-1.3.jar\r\n  * hamcrest-library-1.3.jar \r\n   \r\n* Apache Commons Logging 1.1\r\n  * commons-logging-1.1.1.jar\r\n\r\nOptional dependencies:\r\n\r\n* Jaxen-1.1.4 - for compiling XPath strings into expressions\r\n  * jaxen-1.1.4.jar\r\n  \r\n* JAXB reference implementation 1.0 - for automatic POJO mapping\r\n\r\n====\r\n### Examples\r\n\r\nInsert an instance of `Foo` into the table \"Foo\" stored in \"myDataDirectory/Foo.xml\".\r\n```java\r\nXFlatDatabase db = new XFlatDatabase(new File(\"myDataDirectory\"));\r\n//initialize with default config\r\ndb.initialize();\r\n\r\nFoo myFoo = new Foo();\r\nTable<Foo> fooTable = db.getTable(Foo.class);\r\nfooTable.insert(myFoo);  //inserts with unique automatically-generated ID\r\nSystem.out.println(\"Stored foo in table Foo with ID \" + myFoo.getId());\r\n\r\nFoo myFoo2 = fooTable.find(myFoo.getId());\r\n//myFoo2 is a new instance with the same data as myFoo\r\n```\r\n\r\nSee \"Examples.md\" for more examplesXFlat\r\n=====\r\n\r\nA lightweight embedded no-sql object DB persisting objects to flat XML files.\r\nXFlat is a completely free alternative to db4o for an embedded object DB.\r\n\r\n----\r\n\r\nSo you've got a Java application, and need to persist some data.  Cool.  Just write it to a file.\r\n\r\n> Well, my data's in a bunch of POJOs.\r\n\r\nOk that's easy, just serialize it to XML and drop it into a DOM, then write it to a file.\r\n\r\n> Alright, that sounds easy enough.  But wait a second, I need random access to my saved POJOs.\r\n\r\nWell thats a bit harder, but you could write a class to inspect the DOM and pull out the data you need.\r\n\r\n> But I also need to query my POJOs by arbitrary criteria.\r\n\r\nLooks like you need a database.  Take a look at db4o or Sql Lite\r\n\r\n> Well I'd prefer not to have to deal with Sql, and I may need to inspect or transform my data as XML.\r\n\r\nOh, well in that case XFlat is for you!\r\n\r\n---\r\n\r\nXFlat is a single lightweight JAR that persists XML DOM Elements to flat files.\r\nIt presents as a CRUD interface to XML Elements that can be queried by ID or arbitrary XPath expressions.\r\nBecause it is stored in flat files, XFlat is not relational and is schemaless.\r\nXFlat is currently effective for table sizes up to the dozens of KB.  Future versions will contain engines that are\r\neffective up to the hundreds of MB, using memory-mapped files.\r\n\r\n\r\n#### Features:\r\n* Pure XML data files\r\n  * XFlat's data files are pure XML.  This means they can be inspected, queried, transformed and manipulated by common\r\nXML tools like XSLT and XQuery.  It is trivial to create a process to export your entire database, or import data\r\nfrom another process into your database by directly manipulating the XML (provided the database is not running during\r\nthe import, which is simple to control).  XFlat will automatically re-index the data files on startup if they have\r\nchanged.\r\n\r\n\r\n* POJO mapping to XML\r\n  * XFlat maps POJOs to JDOM `Element` objects using JAXB.  The underlying implementation can be swapped if necessary.\r\nThe JAXB context is only loaded if it is used, so you can avoid it completely by specifying custom converters,\r\nor using only the JDOM CRUD interface.\r\n\r\n\r\n* Queriable by XPath expressions\r\n  * Tables can be queried by any arbitrary XPath expression using the table row as the context.  The expression\r\nselects a part of the `Element` that is convertible to the value which is being matched, then the matching is performed\r\nusing Hamcrest Matchers.  Breaking the query into XPath expressions and values allows the engine to leverage indexes\r\neffectively, much more easily than if we used XQuery.  Future versions may support XQuery.\r\n\r\n\r\n* Multiple swappable Engines (to be implemented)\r\n  * The management of each table is handled by an Engine.  As a table grows or shrinks, the appropriate Engine for managing\r\nthe data is swapped in behind the scenes.  For example, very small tables can use an engine that loads the whole\r\nXML DOM in-memory, while very large tables can use an engine that manipulates a memory-mapped file.  Only one engine\r\nis implemented for version 1.\r\n\r\n\r\n\r\n* Indexing on XPath expressions (to be implemented)\r\n  * Engines can take advantage of indexes that are based on any arbitrary XPath expression.  The expression selects a\r\npart of the `Element` that is converted to a `Comparable` (such as an Integer), then the engine can map that `Comparable`\r\nto the row and binary search indexes to improve performance.\r\n\r\n\r\n\r\n* Sharding by ID (implemented) or on arbitrary XPath expressions (to be implemented)\r\n  * A table can be sharded across multiple files based on a sharding key selected by an XPath expression.  The expression\r\nselects a part of the `Element` that is converted to a `Comparable`, then a `RangeProvider` determines which file to store\r\nthe Element in.\r\n\r\n\r\n* Transactions\r\n  * XFlat supports Transactions that by default span all tables in the database.  Currently XFlat only implements snapshot-isolation transactions,\r\nserializable transactions are planned for a future version.\r\n\r\n====\r\n\r\nRequired dependencies:\r\n* Java 7\r\n\r\n* JDOM 2\r\n  * jdom-2.0.4.jar\r\n  \r\n* Hamcrest matchers 1.3\r\n  * hamcrest-core-1.3.jar\r\n  * hamcrest-library-1.3.jar \r\n   \r\n* Apache Commons Logging 1.1\r\n  * commons-logging-1.1.1.jar\r\n\r\nOptional dependencies:\r\n\r\n* Jaxen-1.1.4 - for compiling XPath strings into expressions\r\n  * jaxen-1.1.4.jar\r\n  \r\n* JAXB reference implementation 1.0 - for automatic POJO mapping\r\n\r\n====\r\n### Examples\r\n\r\nInsert an instance of `Foo` into the table \"Foo\" stored in \"myDataDirectory/Foo.xml\".\r\n```java\r\nXFlatDatabase db = new XFlatDatabase(new File(\"myDataDirectory\"));\r\n//initialize with default config\r\ndb.initialize();\r\n\r\nFoo myFoo = new Foo();\r\nTable<Foo> fooTable = db.getTable(Foo.class);\r\nfooTable.insert(myFoo);  //inserts with unique automatically-generated ID\r\nSystem.out.println(\"Stored foo in table Foo with ID \" + myFoo.getId());\r\n\r\nFoo myFoo2 = fooTable.find(myFoo.getId());\r\n//myFoo2 is a new instance with the same data as myFoo\r\n```\r\n\r\nSee \"Examples.md\" for more examples","name":"Xflat","note":"Don't delete this file! It's used internally to help with page regeneration."}